## 🎯 Goals

This repository documents my journey to strengthen skills in **software architecture and system design**.  
My current focus is on two major learning tracks:  

---

### 📡 Learn Communication Protocols
- **Internet and Web Protocols** – HTTP, HTTPS, FTP, SFTP, SMTP, IMAP, POP3, DNS  
- **Interprocess and Messaging Protocols** – AMQP, XMPP, WebSockets, gRPC  
- **Network Communication Protocols** – TCP, UDP, IP  
- **Industrial and IoT Protocols** – Modbus, CAN, MQTT  
- **Wireless Communication Protocols** – Wi-Fi, Bluetooth, NFC  
- **Telecommunication Protocols** – VoIP, SIP, RTP  
- **Security and Encryption Protocols** – SSL/TLS, IPSec, SSH, OAuth  

---

### 🏗 Learn Software Design
- **SOLID Principles**  
- **Creational Patterns** – Factory (all kinds), Builder, Singleton, etc.  
- **Structural Patterns** – Adapter, Bridge, Composite, Decorator, Facade, Proxy, etc.  
- **Behavioral Patterns** – Chain of Responsibility, Command, Mediator, Observer, Visitor, Template Method, State, etc.  
- **Anti-Patterns** – God/Manager Class, Singleton Overuse, Overengineering, Programming by Exception, Poltergeists, Boat Anchor, Interface Bloat, Golden Hammer, Premature Optimization  
- **DRY & KISS** – Don’t Repeat Yourself, Keep It Simple Stupid  
- **YAGNI & Occam’s Razor** – Avoid over-engineering and unnecessary features  
- **Separation of Concerns & Modularity** – Decoupling concerns, modular design, best practices  
- **Encapsulation & Information Hiding**  
- **Cohesion & Coupling** – High cohesion, low coupling, trade-offs, refactoring  
- **Design by Contract (DbC)**  
- **Principle of Least Astonishment (POLA)**  
- **Twelve-Factor App Principles** – Scalable, cloud-native best practices (dependencies, configuration, logging, disposability)  
- **Code Reusability & Composition Over Inheritance**  
- **TDD & BDD** – Test-Driven and Behavior-Driven Development  
- **Security-First Development** – Secure coding practices, input validation, authN/authZ patterns, OWASP Top 10 protections  

---

✅ This roadmap ensures I build a **solid foundation in both theoretical concepts and practical implementations**, making me a stronger software architect.  
