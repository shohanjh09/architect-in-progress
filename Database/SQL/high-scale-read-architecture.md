# High-Scale Read Architecture (DB + Cache + Search + Replicas)

> Goal: serve read-heavy traffic with low latency while keeping correctness where needed.

---

## 1) Identify Read Patterns
Before you optimize, list:\n- Top endpoints\n- Query shapes\n- Hot tables\n- Cacheability\n- Consistency requirements\n\nExample patterns:\n- home feed\n- gig listing\n- profile page\n- search\n\n---\n\n## 2) Read Replicas\nUse replicas for read-heavy queries.\n\n### How it works\n- Primary handles writes\n- Replicas replicate changes (async)\n\n### Trade-offs\n- Replication lag\n- Stale reads\n\nGood for:\n- reports\n- listings\n- search pages\n\nNot good for:\n- “I just paid, show my balance now”\n\n---\n\n## 3) Caching Strategies\n\n### 3.1 Cache-aside\nApp checks cache → if miss, read DB → store in cache.\n\nExample pseudo:\n```text\nif cache.has(key): return cache.get(key)\nvalue = db.query(...)\ncache.set(key, value, ttl)\nreturn value\n```\n\n### 3.2 Write-through / Write-behind\nUsed when strong cache consistency needed.\n\n---\n\n## 4) Cache Keys and Invalidation\n\n### Key design\n- Include versioning: `user:10:v2`\n- Include locale/currency: `feed:10:en:USD`\n\n### Invalidation rules\n- Invalidate on write\n- Or use short TTL for eventual correctness\n\nCommon pitfalls:\n- Never invalidating\n- “Cache stampede” on expiry\n\nFix stampede:\n- lock key\n- request coalescing\n- jitter TTL\n\n---\n\n## 5) Materialized Views / Denormalized Tables\nFor heavy joins, precompute.\n\nExamples:\n- user_inbox\n- product_search_index table\n- daily aggregates\n\n---\n\n## 6) Search Separation\nDon’t force DB to handle search at scale.\n\nPattern:\n- DB stores truth\n- Search index stores optimized docs\n- Async pipeline keeps index updated (outbox/CDC)\n\n---\n\n## 7) Pagination at Scale\nPrefer seek pagination over OFFSET.\n\n❌ Bad:\n```sql\nSELECT * FROM posts ORDER BY id DESC LIMIT 50 OFFSET 100000;\n```\n\n✅ Good:\n```sql\nSELECT * FROM posts WHERE id < 900000 ORDER BY id DESC LIMIT 50;\n```\n\n---\n\n## 8) Hotspot Reduction\n\n### Techniques\n- Shard by user_id\n- Partition by time\n- Use caching\n- Split read models\n\n---\n\n## 9) Observability\nTrack:\n- p95/p99 latency\n- slow query logs\n- cache hit rate\n- replica lag\n- lock waits\n\n---\n\n## 10) Interview Summary\n- Use replicas for scale\n- Use caching for latency\n- Use denorm/materialized views for heavy joins\n- Use search engine for text search\n- Use seek pagination\n\n---\n\n**End of file**\n
