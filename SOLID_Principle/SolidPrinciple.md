# SOLID Principles

## Overview
The **SOLID** principles are a set of five design principles in object-oriented programming that help create more understandable, flexible, and maintainable software.

### SOLID Stands For:
- **S** â€“ Single Responsibility Principle (SRP)  
- **O** â€“ Open/Closed Principle (OCP)  
- **L** â€“ Liskov Substitution Principle (LSP)  
- **I** â€“ Interface Segregation Principle (ISP)  
- **D** â€“ Dependency Inversion Principle (DIP)  

---

## âœ… Advantages of SOLID
- Avoid duplicate code  
- Easy to maintain  
- Easy to understand  
- Flexible software design  
- Reduced complexity  

---

## ðŸ“˜ Principles

### 1. Single Responsibility Principle (SRP)
A class should have only one reason to change, meaning it should only have one job.  
[See detailed SingleResposibilityPrinciple.md](SingleResposibilityPrinciple.md)

---

### 2. Open/Closed Principle (OCP)
A class should be open for extension but closed for modification.  
[See detailed OpenClosedPrinciple.md](OpenClosedPrinciple.md)

---

### 3. Liskov Substitution Principle (LSP)
Subtypes must be substitutable for their base types without altering the correctness of the program.  
[See detailed LiskovSubstitutionPrinciple.md](LiskovSubstitutionPrinciple.md)

---

### 4. Interface Segregation Principle (ISP)
Clients should not be forced to implement interfaces they do not use.  
[See detailed InterfaceSegmentedPrinciple.md](InterfaceSegmentedPrinciple.md)

---

### 5. Dependency Inversion Principle (DIP)
High-level modules should not depend on low-level modules. Both should depend on abstractions.  
[See detailed DependencyInversionPrinciple.md](DependencyInversionPrinciple.md)

---

## ðŸŽ¯ Summary
By applying the **SOLID** principles, developers can build:  
- More robust software  
- Systems that are easier to extend with new features  
- Applications that are less prone to bugs when changes are made  

